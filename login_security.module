<?php

/**
 * @file
 * Thwart attempts to brute-force logins.
 */

/**
 * Implements hook_config_info();
 */
function login_security_config_info() {
  $prefixes = array();
  $prefixes['login_security.settings'] = array(
    'group' => t('Configuration'),
    'label' => t('Login security settings'),
  );
  return $prefixes;
}

/**
 * Implements hook_cron().
 *
 * Remove expired events.
 */
function login_security_cron() {
  _login_security_remove_events();
}

/**
 * Implements hook_menu().
 */
function login_security_menu() {
  $items = array();

  // Administer >> Site configuration >> Login Security settings.
  $items['admin/config/people/login_security'] = array(
    'title' => 'Login Security',
    'description' => 'Configure security settings in the login form submission.',
    'access arguments' => array('administer site configuration'),
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('login_security_admin_settings'),
    'file' => 'login_security.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_user_login().
 */
function login_security_user_login(&$edit, $account) {
  _login_security_remove_events($account->name;
}

/**
 * Implements hook_user_update().
 */
function login_security_user_update(&$edit, &$account, $category = NULL) {
  // The update case can be launched by the user or by any administrator.
  // On update, remove only the unser information tracked.
  if ($account->status != 0) {
    // Don't remove tracking events if account is being blocked.
    _login_security_remove_events($account->name);
  }
}

/**
 * Implements hook_form_alter().
 */
function login_security_form_alter(&$form, &$form_state, $form_id) {
  switch ($form_id) {
    case 'user_login':
    case 'user_login_block':
      // Put login_security first or the capture of the previous login
      // timestamp won't work and core's validation will update to the current
      // login instance before login_security can read the old timestamp.
      $validate = array('login_security_set_login_timestamp');

      if (isset($form['#validate']) && is_array($form['#validate'])) {
        $form['#validate'] = array_merge($validate, $form['#validate']);
      }
      else {
        $form['#validate'] = $validate;
      }

      $form['#validate'][] = 'login_security_validate';
      break;
  }
}

/**
 * Save login attempt and save login/access timestamps.
 *
 * Previous incarnations of this code put it in hook_submit or hook_user, but
 * since Backdrop core validation updates the login timestamp, we have to set the
 * message before it gets updated with the current login instance.
 */
function login_security_set_login_timestamp($form, &$form_state) {
  // Save entry in security log, Username and IP Address.
  _login_security_add_event($form_state['values']['name']);
}

/**
 * Returns account login timestamp.
 */
function _login_security_login_timestamp($login = NULL) {
  static $account_login;
  if (!isset($account_login) && is_numeric($login) && $login > 0) {
    $account_login = $login;
  }
  return $account_login;
}

/**
 * Returns account access timestamp.
 */
function _login_security_access_timestamp($access = NULL) {
  static $account_access;
  if (!isset($account_access) && is_numeric($access) && $access > 0) {
    $account_access = $access;
  }
  return $account_access;
}

/**
 * Implements hook_validate().
 *
 * This functions does more than just validating, but it's main intention is to
 * break the login form flow.
 */
function login_security_validate($form, &$form_state) {
  // Sanitize user input.
  $name = $form_state['values']['name'];
  // Null username should not be tracked.
  if (!strlen($name)) {
    return;
  }

  // Expire old tracked entries.
  _login_security_remove_events();

  // Populate variables to be used in any module message or login operation.
  $variables = _login_security_get_variables_by_name($name);

  // First, check if administrator should be notified of unexpected login
  // activity.
  // Only process if configured threshold > 1.
  // see: http://backdrop.org/node/583092.

  // Check for user login attempts.
  if ($variables['@user_block_attempts'] >= 1) {
    if ($variables['@user_current_count'] >= $variables['@user_block_attempts']) {
      // Block the account $name.
      login_user_block_user_name($variables);
    }
  }

  // At this point, they're either logged in or not by Backdrop core's abuse of
  // the validation hook to login users completely.
  global $user;

  // Login failed.
  $messages = backdrop_get_messages('error', FALSE);

  if (!empty($messages['error'])) {
    $password_message = preg_grep("/<a href=\"\/user\/password\?name=$name\">Have you forgotten your password\?<\/a>/", $messages['error']);
    $block_message = preg_grep("/The username <em class=\"placeholder\">$name<\/em> has not been activated or is blocked./", $messages['error']);

    if (!count($password_message) || !count($block_message)) {
      // Should the user be advised about the remaining login attempts?
      $notice_user = config_get('login_security.settings', 'login_security_notice_attempts_available');
      if (($notice_user == TRUE) && ($variables['@user_block_attempts'] > 0) && $variables['@user_block_attempts'] >= $variables['@user_current_count']) {

        // Simple flag that can be changed using hook_alter (see below).
        $display_block_attempts = TRUE;

        // Allow other module to change the flag, or even the message displayed,
        // with a custom logic.
        backdrop_alter('login_security_display_block_attempts');

        $message = array(
          'message' => $message_raw,
          'variables' => $variables
        );

        if ($display_block_attempts) {
// @TODO: add @current_user_count replacement.
          backdrop_set_message(t("You have used @user_current_count out of @user_block_attempts login attempts. After all @user_block_attempts have been used, you will be unable to login.", array('@user_block' => $variables['@user_current_count'])), 'warning', TRUE);
        }
      }
    }
  }
}

/**
 * Remove tracked events or expire old ones.
 *
 * @param string $name
 *   If specified, events for this user name will be removed.
 */
function _login_security_remove_events($name = NULL) {
  // Remove selected events.
  if (!empty($name)) {
    $result = db_delete('login_security_track')
      ->condition('name', $name)
      ->execute();
  }
  else {
    // Calculate protection time window and remove expired events.
    $time = REQUEST_TIME - (config_get('login_security.settings', 'login_security_track_time') * 60);
    _login_security_remove_all_events($time);
  }
}

/**
 * Remove all tracked events up to a date..
 *
 * @param int $time
 *   if specified, events up to this timestamp will be deleted. If not
 *   specified, all elements up to current timestamp will be deleted.
 */
function _login_security_remove_all_events($time = NULL) {
  // Remove selected events.
  if (empty($time)) {
    $time = REQUEST_TIME;
  }
  $result = db_delete('login_security_track')
    ->condition('timestamp', $time, '<')
    ->execute();
}

/**
 * Save the login attempt in the tracking database: user name nd ip address.
 *
 * @param string $name
 *   user name to be tracked.
 */
function _login_security_add_event($name) {
  // Each attempt is kept for future mining of advanced bruteforcing like
  // multiple IP or X-Forwarded-For usage and automated track data cleanup.
  $event = new stdClass();
  $event->host = $ip;
  $event->name = $name;
  $event->timestamp = REQUEST_TIME;
  backdrop_write_record('login_security_track', $event);
}

/**
 * Block a user by user name. If no user id then block current user.
 */
function login_user_block_user_name($variables) {
  // If the user exists.
  if ($variables['@uid'] > 1) {
    // Modifying the user table is not an option so it disables the user hooks.
    // Need to do firing the hook so user_notifications can be used.
    // db_query("UPDATE {users} SET status = 0 WHERE uid = %d", $uid);
    $uid = $variables['@uid'];
    $account = user_load($uid);

    // Block account if is active.
    if ($account->status == 1) {
      user_save($account, array('status' => 0), NULL);
      // Remove user from site now.
      backdrop_session_destroy_uid($uid);
      // The watchdog alert is set to 'user' so it will show with other blocked
      // user messages.
      watchdog('user', 'Blocked user @username due to security configuration.', $variables, WATCHDOG_NOTICE, l(t('edit user'), "user/{$variables['@uid']}/edit", array('query' => array('destination' => 'admin/user/user'))));
      // Also notify the user that account has been blocked.
      form_set_error('void', t("The user @username has been blocked due to failed login attempts.", $variables));

      // Send admin email.
      $user_blocked_email_user = config_get('login_security.settings', 'login_security_user_blocked_email_user');
      if ($user_blocked_email_user !== '') {
        $from = config_get('login_security.settings', 'site_mail');
        $admin_mail = db_select('users', 'u')
          ->fields('u', array('mail'))
          ->condition('name', $user_blocked_email_user)
          ->execute()
          ->fetchField();
        return backdrop_mail('login_security', 'block_user_notify', $admin_mail, language_default(), $variables, $from, TRUE);
      }
    }
  }
}


/**
 * Helper function to get the variable array for the messages.
 */
function _login_security_get_variables_by_name($name) {
  $account = user_load_by_name($name);
  // https://backdrop.org/node/1744704
  if (empty($account)) {
    $account = user_load(0);
  }
  $ipaddress = ip_address();
  global $base_url;
  $variables = array(
    '@date' => format_date(REQUEST_TIME),
    '@ip' => $ipaddress,
    '@username' => $account->name,
    '@email' => $account->mail,
    '@uid' => $account->uid,
    '@site' => config_get('login_security.settings', 'site_name'),
    '@uri' => $base_url,
    '@edit_uri' => url('user/' . $account->uid . '/edit', array('absolute' => TRUE)),
    '@user_block_attempts' => config_get('login_security.settings', 'login_security_user_wrong_count'),
    '@user_ip_current_count' => db_select('login_security_track', 'lst')
    ->fields('lst', array('id'))
    ->condition('name', $name)
    ->condition('host', $ipaddress)
    ->countQuery()
    ->execute()
    ->fetchField(),
    '@ip_current_count' => db_select('login_security_track', 'lst')
    ->fields('lst', array('id'))
    ->condition('host', $ipaddress)
    ->countQuery()
    ->execute()
    ->fetchField(),
    '@user_current_count' => db_select('login_security_track', 'lst')
    ->fields('lst', array('id'))
    ->condition('name', $name)
    ->countQuery()
    ->execute()
    ->fetchField(),
    '@tracking_time' => config_get('login_security.settings', 'login_security_track_time'),
    '@tracking_current_count' => db_select('login_security_track', 'lst')
    ->fields('lst', array('id'))
    ->countQuery()
    ->execute()
    ->fetchField(),
    '@activity_threshold' => config_get('login_security.settings', 'login_security_activity_threshold'),
  );
  return $variables;
}

/**
 * Implements hook_mail().
 */
function login_security_mail($key, &$message, $variables) {
  switch ($key) {
    case 'block_user_notify':
      $message['subject'] = t("Security action: The user @username has been blocked", $variables);
      $message['body'][] = t("The user @username (@edit_uri) has been blocked at @site due to the amount of failed login attempts. Please check the logs for more information.", $variables);
      break;

    case 'login_activity_notify':
      $message['subject'] = t("Security information: Unexpected login activity has been detected at @site.", $variables);
      $message['body'][] = t("The configured threshold of @activity_threshold logins has been reached with a total of @tracking_current_count invalid login attempts. You should review your log information about login attempts at @site.", $variables);
      break;
  }
}
