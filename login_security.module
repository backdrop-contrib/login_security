<?php

/**
 * @file
 * Thwart attempts to brute-force logins.
 */

/**
 * Implements hook_config_info();
 */
function login_security_config_info() {
  $prefixes = array();
  $prefixes['login_security.settings'] = array(
    'group' => t('Configuration'),
    'label' => t('Login security settings'),
  );
  return $prefixes;
}

/**
 * Implements hook_cron().
 *
 * Remove expired events.
 */
function login_security_cron() {
  _login_security_remove_events();
}

/**
 * Implements hook_menu().
 */
function login_security_menu() {
  $items = array();

  $items['admin/config/people/login_security'] = array(
    'title' => 'Login Security',
    'description' => 'Configure security settings in the login form submission.',
    'access arguments' => array('administer site configuration'),
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('login_security_admin_settings'),
    'file' => 'login_security.admin.inc',
  );

  $items['login_security_clean_tracked_events'] = array(
    'title' => 'Clear tracking information',
    'access arguments' => array('administer users'),
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('login_security_clean_tracked_events'),
    'file' => 'login_security.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_user_login().
 */
function login_security_user_login(&$edit, $account) {
  _login_security_remove_events($account->name);
}

/**
 * Implements hook_user_update().
 */
function login_security_user_update(&$edit, &$account, $category = NULL) {
  // The update case can be launched by the user or by any administrator.
  // On update, remove only the unser information tracked.
  if ($account->status != 0) {
    // Don't remove tracking events if account is being blocked.
    _login_security_remove_events($account->name);
  }
}

function login_security_watchdog($log_entry) {
  switch ($log_entry['type']) {
    case 'user';
      if ($log_entry['message'] == 'Login attempt failed for %user.') {
        login_security_add_event($log_entry['variables']['%user']);
      }
      break;
  }
}

/**
 * Implements hook_form_alter().
 */
function login_security_form_alter(&$form, &$form_state, $form_id) {
  switch ($form_id) {
    case 'user_login':
    case 'user_login_block':
      // Put login_security first because if the core validation passes
      // the user will be logged in.
      $validate = array('login_security_check_events');

      if (isset($form['#validate']) && is_array($form['#validate'])) {
        $form['#validate'] = array_merge($validate, $form['#validate']);
      }
      else {
        $form['#validate'] = $validate;
      }
      break;
  }
}

/**
 * Check to see if the login attempt exceeds the limit in the alloted time.
 */
function login_security_check_events($form, &$form_state) {
  $config = config('login_security.settings');

  // Since the objective is to deter brute force password guessing,
  // we shouldn't cause a DoS from a valid user attempting to login.
  // This limits invalid login attempts coming from the same IP address
  // instead all attempts from any address.
  $user_current_count = db_select('login_security', 'n')
    ->fields('n')
    ->condition(
      db_and()
        ->condition('name', $form_state['values']['name'])
        ->condition('host', ip_address())
        ->condition('timestamp', REQUEST_TIME - _login_security_track_time(), '>')
    )
    ->countQuery()
    ->execute()
    ->fetchField();

  if ($config->get('login_security_user_wrong_count') >= 1) {
    if ($user_current_count >= $config->get('login_security_user_wrong_count')) {
      // Block the account $name.
      form_set_error('', t('This account is temporarily disabled.'));
      watchdog('login_security', t('Access denied for %user.'), array('%user' => $form_state['values']['name']), WATCHDOG_DEBUG);
    }
  }
}

/**
 * Remove tracked events or expire old ones.
 *
 * @param string $name
 *   If specified, events for this user name will be removed.
 */
function _login_security_remove_events($name = NULL) {
  // Remove selected events.
  if (!empty($name)) {
    $result = db_delete('login_security')
      ->condition('name', $name)
      ->execute();
  }
  else {
    // Calculate protection time window and remove expired events.
    $time = REQUEST_TIME - _login_security_track_time();
    _login_security_remove_all_events($time);
  }
}

/**
 * Remove all tracked events up to a date..
 *
 * @param int $time
 *   if specified, events up to this timestamp will be deleted. If not
 *   specified, all elements up to current timestamp will be deleted.
 */
function _login_security_remove_all_events($time = NULL) {
  // Remove selected events.
  if (empty($time)) {
    $time = REQUEST_TIME;
  }
  db_delete('login_security')
    ->condition('timestamp', $time, '<')
    ->execute();
  watchdog('login_security', t('All login events deleted older than @time.'), array('@time' => date_format($time)), WATCHDOG_DEBUG);
}

/**
 * Save the login attempt in the tracking database for the username.
 *
 * @param string $name
 *   user name to be tracked.
 */
function login_security_add_event($name) {
  // Each attempt is kept for future mining of advanced bruteforcing like
  // multiple IP or X-Forwarded-For usage and automated track data cleanup.
  $event = new stdClass();
  $event->host = ip_address();
  $event->name = $name;
  $event->timestamp = REQUEST_TIME;
  backdrop_write_record('login_security', $event);
}

/**
 * Convert tracked time in minutes to seconds.
 *
 * @return int
 */
function _login_security_track_time() {
  return config_get('login_security.settings', 'login_security_track_time') * 60;
}
